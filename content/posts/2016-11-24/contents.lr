title: 파이썬 의존성 관리
---
pub_date: 2016-11-24
---
body:

> ![requirements.txt 파일](/posts/2016-11-24/requirements.png)
> *<small>일반적인 pip 프로젝트의 requirements.txt. 주 의존성과 부수적 의존성의 구분이 없다</small>*

파이썬의 [훌륭한 생태계][3]에도 불구하고 큰 프로젝트를 시작할 때면 <small>requirements.txt</small>를 통해 의존성을 관리하는 방식 때문에 고생을 한 적이 한 두번이 아니다. pip 프로젝트의 경우 <small>pip freeze</small>를 통해 현재 파이썬 런타임에 설치된 패키지들의 버전들을 pin하여 <small>requirements.txt</small>에 기록하는데, 이런식으로 의존성을 관리할 경우 주 의존성과 부수적 의존성들을 구분하기 어렵고, 그에 따라 라이브러리 버전 업데이트가 필요한 경우 수작업을 통해 서로의 요구조건에 부합하는 버전을 짜맞추어야 하는 [처참한 상황][4]이 발생할 수 있다.

가령 기존의 주 의존성 A.1이 B.2x에 의존하고, 새로 업데이트 된 A.2가 B.3x에 의존하는 상황을 생각해보자. 이 상황에서 단순히 주어진 <small>requirements.txt</small>의 A.1을 A.2로 바꾸어 의존성을 업데이트 하려는 경우 B에서 버전충돌이 일어나게 된다. 눈대중으로 <small>requirements.txt</small>을 흝어보며 B도 알맞게 버전을 갱신해주는 방법으로 해결 가능하지만, 큰 규모에서 이런 일이 발생할 경우 정말 절망적이다.

이 문제는 사실 <small>requirements.txt</small>에 pinned 의존성을 저장하는 기존 방식 그 자체 때문이 아니라, **주 의존성의 semantic versioning과 전체 의존성의 pinned version을 저장하는 두 가지 메커니즘을 동시에 제공하지 않기 때문에 발생하는 문제다.**

다행히도 pypa에서 이 두 가지 기능을 동시에 제공하는 [<small>Pipfile</small>의 명세를 작성하는 작업을 며칠 전 시작했다][1]. 아직 확정되진 않았지만, 다음과 같은 부분이 크게 달라질 것으로 보인다.

> ![Pipfile 파일](/posts/2016-11-24/pipfile.png)
> *<small>현재 명세 초안에 공개된 Pipfile 예시. Pipfile은 주 의존성만을 기록하고, 전체 의존성은 Pipfile.lock에 pin된다</small>*

- <small>requirements.txt</small>에 현재 파이썬 런타임에 설치된 모든 패키지들을 pin하여 저장하는 대신, 프로젝트에 필요한 주 의존성들만 <small>Pipfile</small>에 기록하여 관리한다.

- <small>Pipfile</small>에서 관리되는 주 의존성을 포함한 빌드 순간의 프로젝트 전체 의존성은 <small>Pipfile.lock</small>에 pin되어 기록된다. hash 체크섬 기능을 지원하므로 배포환경에서도 언제나 deterministic하게 빌드를 재생산 가능함이 보장된다.

- 개발환경과 배포환경에서의 의존성을 따로 관리할 수 있도록 의존성 분리 기능을 지원한다.

처음 두 기능은 루비의 Bundler와 PHP의 Composer에서 의존성을 관리하던 방식으로, 주 의존성과 전체 pinned 의존성을 따로 관리할 수 있게함으로서 의존성 업데이트의 편리함과 빌드의 deterministic한 재생산 가능성을 보장해 줄 것이다.

마지막 기능은 npm에서 요긴하게 쓰이던 기능으로, 이전에는 <small>requirements.dev.txt</small>와 <small>requirements.prod.txt</small>에 개발환경 의존성과 배포환경 의존성을 나누어 기록했다면, 이제 이 기능을 통해 <small>Pipfile</small> 하나로 두 가지 환경에 대한 의존성을 함께 관리할 수 있게 될 것으로 보인다.

이외에도 플랫폼 별 의존성을 따로 설정할 수 있게끔 하는 등, 다양한 패키징 옵션들이 추가될 것으로 예상된다.

현재 명세 초안에서 <small>Pipfile</small>의 포맷이 정적인 JSON이나 TOML가 아닌, [일반 파이썬 executable로 구상되어 있는 점에 대한 논란][5]이 있긴 하지만, 개인적으로 이 정도면 기존의 절망적인 상황에 비해 큰 발전이라고 본다. <small>Pipfile</small> 구현체의 배포는 아마 파이썬 3.4/3.5에 <small>asyncio</small>와 함께 <small>async</small> <small>await</small> 키워드가 추가된 이후로 파이썬 생태계에 가장 큰 임팩트를 줄 변화가 되지 않을까 싶다.


[1]: https://github.com/pypa/pipfile
[2]: https://www.pypa.io/en/latest/
[3]: ../2016-11-23
[4]: https://www.kennethreitz.org/essays/a-better-pip-workflow#thefrustrations
[5]: https://news.ycombinator.com/item?id=13011932#unv_13012683
